generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========== 사용자 ==========

enum UserRole {
  SUPPLIER
  CONSUMER
  ADMIN
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

model User {
  id           String     @id @default(uuid())
  email        String     @unique
  password     String
  name         String
  role         UserRole
  organization String
  status       UserStatus @default(ACTIVE)
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")

  didCredential   DIDCredential?
  orders          Order[]
  meterReadings   MeterReading[]
  buyTrades       Trade[]          @relation("BuyerTrades")
  sellTrades      Trade[]          @relation("SellerTrades")
  buySettlements  Settlement[]     @relation("BuyerSettlements")
  sellSettlements Settlement[]     @relation("SellerSettlements")
  supplierCerts   RECCertificate[] @relation("SupplierCerts")
  consumerCerts   RECCertificate[] @relation("ConsumerCerts")

  // EPC 토큰 관계
  tokenBalance    TokenBalance?
  tokenTxFrom     TokenTransaction[] @relation("TokenTxFrom")
  tokenTxTo       TokenTransaction[] @relation("TokenTxTo")
  issuedRECTokens RECToken[]         @relation("RECTokenIssuer")
  ownedRECTokens  RECToken[]         @relation("RECTokenOwner")

  @@map("users")
}

// ========== DID 인증 ==========

enum DIDStatus {
  ACTIVE
  REVOKED
}

model DIDCredential {
  id        String    @id @default(uuid())
  userId    String    @unique @map("user_id")
  did       String    @unique
  publicKey String    @map("public_key")
  status    DIDStatus @default(ACTIVE)
  issuedAt  DateTime  @default(now()) @map("issued_at")

  user User @relation(fields: [userId], references: [id])

  @@map("did_credentials")
}

// ========== 전력 거래 ==========

enum OrderType {
  BUY
  SELL
}

enum OrderStatus {
  PENDING
  PARTIALLY_FILLED
  FILLED
  CANCELLED
  EXPIRED
}

enum EnergySource {
  SOLAR
  WIND
  HYDRO
  BIOMASS
  GEOTHERMAL
}

model Order {
  id           String       @id @default(uuid())
  userId       String       @map("user_id")
  type         OrderType
  energySource EnergySource @map("energy_source")
  quantity        Float           // kWh
  price           Float           // KRW or EPC per kWh
  remainingQty    Float           @map("remaining_qty")
  paymentCurrency PaymentCurrency @default(KRW) @map("payment_currency")
  status          OrderStatus     @default(PENDING)
  validFrom    DateTime     @map("valid_from")
  validUntil   DateTime     @map("valid_until")
  createdAt    DateTime     @default(now()) @map("created_at")
  updatedAt    DateTime     @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id])

  buyTrades  Trade[] @relation("BuyOrderTrades")
  sellTrades Trade[] @relation("SellOrderTrades")

  @@index([type, status, energySource])
  @@index([userId])
  @@map("orders")
}

enum TradeStatus {
  MATCHED
  CONFIRMED
  SETTLED
  DISPUTED
  CANCELLED
}

model Trade {
  id           String       @id @default(uuid())
  buyOrderId   String       @map("buy_order_id")
  sellOrderId  String       @map("sell_order_id")
  buyerId      String       @map("buyer_id")
  sellerId     String       @map("seller_id")
  energySource EnergySource @map("energy_source")
  quantity        Float           // kWh
  price           Float           // KRW or EPC per kWh
  totalAmount     Float           @map("total_amount")
  paymentCurrency PaymentCurrency @default(KRW) @map("payment_currency")
  status          TradeStatus     @default(MATCHED)
  txHash       String?      @map("tx_hash")
  createdAt    DateTime     @default(now()) @map("created_at")
  updatedAt    DateTime     @updatedAt @map("updated_at")

  buyOrder  Order @relation("BuyOrderTrades", fields: [buyOrderId], references: [id])
  sellOrder Order @relation("SellOrderTrades", fields: [sellOrderId], references: [id])
  buyer     User  @relation("BuyerTrades", fields: [buyerId], references: [id])
  seller    User  @relation("SellerTrades", fields: [sellerId], references: [id])

  settlement     Settlement?
  recCertificate RECCertificate?

  @@index([status])
  @@index([buyerId])
  @@index([sellerId])
  @@map("trades")
}

// ========== 미터링 ==========

model MeterReading {
  id          String       @id @default(uuid())
  userId      String       @map("user_id")
  timestamp   DateTime
  production  Float        @default(0) // kWh
  consumption Float        @default(0) // kWh
  source      EnergySource
  deviceId    String       @map("device_id")
  createdAt   DateTime     @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id])

  @@index([userId, timestamp])
  @@index([deviceId])
  @@map("meter_readings")
}

// ========== 정산 ==========

enum SettlementStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model Settlement {
  id        String           @id @default(uuid())
  tradeId   String           @unique @map("trade_id")
  buyerId   String           @map("buyer_id")
  sellerId  String           @map("seller_id")
  amount          Float            // KRW or EPC
  fee             Float            @default(0)
  netAmount       Float            @map("net_amount")
  paymentCurrency PaymentCurrency  @default(KRW) @map("payment_currency")
  epcPrice        Float?           @map("epc_price") // EPC basket price at settlement time
  status          SettlementStatus @default(PENDING)
  txHash          String?          @map("tx_hash")
  settledAt       DateTime?        @map("settled_at")
  createdAt DateTime         @default(now()) @map("created_at")

  trade  Trade @relation(fields: [tradeId], references: [id])
  buyer  User  @relation("BuyerSettlements", fields: [buyerId], references: [id])
  seller User  @relation("SellerSettlements", fields: [sellerId], references: [id])

  @@index([status])
  @@map("settlements")
}

// ========== REC 인증서 ==========

model RECCertificate {
  id           String       @id @default(uuid())
  tradeId      String       @unique @map("trade_id")
  supplierId   String       @map("supplier_id")
  consumerId   String       @map("consumer_id")
  energySource EnergySource @map("energy_source")
  quantity     Float        // kWh
  issuedAt     DateTime     @default(now()) @map("issued_at")
  validUntil   DateTime     @map("valid_until")
  txHash       String?      @map("tx_hash")

  trade    Trade @relation(fields: [tradeId], references: [id])
  supplier User  @relation("SupplierCerts", fields: [supplierId], references: [id])
  consumer User  @relation("ConsumerCerts", fields: [consumerId], references: [id])

  recToken RECToken?

  @@map("rec_certificates")
}

// ========== EPC 토큰 ==========

enum TokenTxType {
  MINT
  BURN
  TRANSFER
  LOCK
  UNLOCK
}

enum PriceSource {
  EIA
  ENTSOE
  KPX
}

enum PaymentCurrency {
  KRW
  EPC
}

enum RECTokenStatus {
  ACTIVE
  TRANSFERRED
  RETIRED
}

model TokenBalance {
  id            String   @id @default(uuid())
  userId        String   @unique @map("user_id")
  balance       Float    @default(0)
  lockedBalance Float    @default(0) @map("locked_balance")
  updatedAt     DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id])

  @@map("token_balances")
}

model TokenTransaction {
  id        String      @id @default(uuid())
  type      TokenTxType
  fromId    String?     @map("from_id")
  toId      String?     @map("to_id")
  amount    Float
  reason    String?
  refId     String?     @map("ref_id")
  txHash    String?     @map("tx_hash")
  createdAt DateTime    @default(now()) @map("created_at")

  fromUser User? @relation("TokenTxFrom", fields: [fromId], references: [id])
  toUser   User? @relation("TokenTxTo", fields: [toId], references: [id])

  @@index([fromId])
  @@index([toId])
  @@index([type])
  @@index([refId])
  @@map("token_transactions")
}

// ========== 가격 오라클 ==========

model PriceOracle {
  id        String      @id @default(uuid())
  source    PriceSource
  price     Float
  priceUsd  Float       @map("price_usd")
  currency  String
  region    String?
  timestamp DateTime
  createdAt DateTime    @default(now()) @map("created_at")

  @@index([source, timestamp])
  @@map("price_oracle")
}

model PriceBasket {
  id               String   @id @default(uuid())
  weightedAvgPrice Float    @map("weighted_avg_price")
  eiaPrice         Float?   @map("eia_price")
  eiaWeight        Float?   @map("eia_weight")
  entsoePrice      Float?   @map("entsoe_price")
  entsoeWeight     Float?   @map("entsoe_weight")
  kpxPrice         Float?   @map("kpx_price")
  kpxWeight        Float?   @map("kpx_weight")
  isStale          Boolean  @default(false) @map("is_stale")
  txHash           String?  @map("tx_hash")
  timestamp        DateTime
  createdAt        DateTime @default(now()) @map("created_at")

  @@index([timestamp])
  @@map("price_baskets")
}

// ========== REC 토큰 (NFT) ==========

model RECToken {
  id           String         @id @default(uuid())
  certId       String?        @unique @map("cert_id")
  tradeId      String?        @map("trade_id")
  issuerId     String         @map("issuer_id")
  ownerId      String         @map("owner_id")
  energySource EnergySource   @map("energy_source")
  quantity     Float
  vintage      String
  location     String?
  status       RECTokenStatus @default(ACTIVE)
  issuedAt     DateTime       @default(now()) @map("issued_at")
  validUntil   DateTime       @map("valid_until")
  retiredAt    DateTime?      @map("retired_at")
  retiredBy    String?        @map("retired_by")
  txHash       String?        @map("tx_hash")
  metadataHash String?        @map("metadata_hash")

  issuer      User            @relation("RECTokenIssuer", fields: [issuerId], references: [id])
  owner       User            @relation("RECTokenOwner", fields: [ownerId], references: [id])
  certificate RECCertificate? @relation(fields: [certId], references: [id])

  @@index([ownerId, status])
  @@index([issuerId])
  @@index([status])
  @@map("rec_tokens")
}

// ========== 블록체인 트랜잭션 ==========

enum BlockchainTxType {
  DID
  TRADE
  SETTLEMENT
  METERING
  EPC_MINT
  EPC_BURN
  EPC_TRANSFER
  EPC_PRICE
  REC_TOKEN
}

enum BlockchainTxStatus {
  PENDING
  CONFIRMED
  FAILED
}

model BlockchainTransaction {
  id        String             @id @default(uuid())
  txHash    String             @unique @map("tx_hash")
  type      BlockchainTxType
  data      Json
  status    BlockchainTxStatus @default(PENDING)
  createdAt DateTime           @default(now()) @map("created_at")

  @@index([type, status])
  @@map("blockchain_transactions")
}
